"use strict";(self.webpackChunkdotslash_website=self.webpackChunkdotslash_website||[]).push([[87],{3905:(e,t,a)=>{a.r(t),a.d(t,{MDXContext:()=>d,MDXProvider:()=>u,mdx:()=>g,useMDXComponents:()=>c,withMDXComponents:()=>h});var n=a(67294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(){return o=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var a=arguments[t];for(var n in a)Object.prototype.hasOwnProperty.call(a,n)&&(e[n]=a[n])}return e},o.apply(this,arguments)}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var d=n.createContext({}),h=function(e){return function(t){var a=c(t.components);return n.createElement(e,o({},t,{components:a}))}},c=function(e){var t=n.useContext(d),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},u=function(e){var t=c(e.components);return n.createElement(d.Provider,{value:t},e.children)},p="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},f=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,o=e.originalType,r=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),h=c(a),u=i,p=h["".concat(r,".").concat(u)]||h[u]||m[u]||o;return a?n.createElement(p,s(s({ref:t},d),{},{components:a})):n.createElement(p,s({ref:t},d))}));function g(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=a.length,r=new Array(o);r[0]=f;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[p]="string"==typeof e?e:i,r[1]=s;for(var d=2;d<o;d++)r[d]=a[d];return n.createElement.apply(null,r)}return n.createElement.apply(null,a)}f.displayName="MDXCreateElement"},10251:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>d});var n=a(87462),i=(a(67294),a(3905));const o={sidebar_position:24},r="Limitations",s={unversionedId:"limitations",id:"limitations",title:"Limitations",description:"As DotSlash aspires to do one thing well, there are inevitably many things it",source:"@site/docs/limitations.md",sourceDirName:".",slug:"/limitations",permalink:"/docs/limitations",draft:!1,editUrl:"https://github.com/facebook/dotslash/tree/main/website/docs/limitations.md",tags:[],version:"current",sidebarPosition:24,frontMatter:{sidebar_position:24},sidebar:"tutorialSidebar",previous:{title:"How DotSlash Works",permalink:"/docs/execution"},next:{title:"DotSlash on Windows",permalink:"/docs/windows"}},l={},d=[{value:"DotSlash is not a package manager",id:"dotslash-is-not-a-package-manager",level:2},{value:"DotSlash is not a general file distribution mechanism",id:"dotslash-is-not-a-general-file-distribution-mechanism",level:2},{value:"DotSlash can fail when URLs go stale",id:"dotslash-can-fail-when-urls-go-stale",level:2},{value:"Debug Symbols",id:"debug-symbols",level:2},{value:"Potential Version Skew Between Code Changes and DotSlash Changes",id:"potential-version-skew-between-code-changes-and-dotslash-changes",level:2}],h={toc:d},c="wrapper";function u(e){let{components:t,...a}=e;return(0,i.mdx)(c,(0,n.Z)({},h,a,{components:t,mdxType:"MDXLayout"}),(0,i.mdx)("h1",{id:"limitations"},"Limitations"),(0,i.mdx)("p",null,"As DotSlash aspires to do one thing well, there are inevitably many things it\ndoes poorly. Because DotSlash is unlikely to expand beyond its original charter,\nits limitations are equally unlikely to change. To that end, it is imporant to\nunderstand the tradeoffs it makes when deciding whether DotSlash is the right\ntool for the job."),(0,i.mdx)("h2",{id:"dotslash-is-not-a-package-manager"},"DotSlash is not a package manager"),(0,i.mdx)("p",null,"Package managers such as ",(0,i.mdx)("a",{parentName:"p",href:"https://rpm-packaging-guide.github.io/"},"RPM")," and\n",(0,i.mdx)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/APT_(software)"},"APT"),' are tools in the "software\ndistribution" space that have a number of features that DotSlash lacks, which\nmay be critical to your use case. Examples include:'),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},'A concept of "dependent packages." For example, an RPM for\n',(0,i.mdx)("a",{parentName:"li",href:"https://eslint.org/"},"ESLint")," could declare a dependency on the RPM for\nNode.js so that the ESLint RPM could be written assuming that ",(0,i.mdx)("inlineCode",{parentName:"li"},"/usr/bin/node"),"\nis on the user's ",(0,i.mdx)("inlineCode",{parentName:"li"},"$PATH"),". By comparison, if ESLint were packaged using\nDotSlash and it used a DotSlash wrapper to invoke Node.js, then things would\nbe a bit different:",(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},"The true ",(0,i.mdx)("inlineCode",{parentName:"li"},"node")," binary would not be downloaded until ESLint was run and\nexercised its internal DotSlash file for Node.js."),(0,i.mdx)("li",{parentName:"ul"},"It would not have the side-effect of adding ",(0,i.mdx)("inlineCode",{parentName:"li"},"node")," to the user's ",(0,i.mdx)("inlineCode",{parentName:"li"},"$PATH"),"."),(0,i.mdx)("li",{parentName:"ul"},"Removing the ESLint DotSlash file (or even the artifact corresponding to it)\nwould not provide any information to suggest that the Node.js artifact\ndownloaded by DotSlash could be removed, as well."))),(0,i.mdx)("li",{parentName:"ul"},"The ability to put files in a specific place on disk. For example, an RPM may\nwrite to folders such as ",(0,i.mdx)("inlineCode",{parentName:"li"},"/etc/bash_completion.d")," or ",(0,i.mdx)("inlineCode",{parentName:"li"},"/usr/share/man")," as part\nof installing a package so that the user automatically gets support for the\ncorresponding Bash completions and ",(0,i.mdx)("inlineCode",{parentName:"li"},"man")," pages. A tool delivered via DotSlash\ndoes not have such affordances, though adding a subcommand to your CLI akin to\n",(0,i.mdx)("a",{parentName:"li",href:"https://rust-lang.github.io/rustup/installation/index.html#enable-tab-completion-for-bash-fish-zsh-or-powershell"},(0,i.mdx)("inlineCode",{parentName:"a"},"rustup completions")),"\nis a good workaround for the former.")),(0,i.mdx)("h2",{id:"dotslash-is-not-a-general-file-distribution-mechanism"},"DotSlash is not a general file distribution mechanism"),(0,i.mdx)("p",null,"DotSlash is designed exclusively for fetching and running executable files. One\nof our fundamental design principles has been to keep DotSlash small and to\nprovide minimal overhead when launching an executable. Extending it to support\ngeneral file distribution feels at odds with that."),(0,i.mdx)("p",null,"If you are determined to use DotSlash in this way, you can always create an\nexecutable that writes a specific data payload to a specified output folder!"),(0,i.mdx)("h2",{id:"dotslash-can-fail-when-urls-go-stale"},"DotSlash can fail when URLs go stale"),(0,i.mdx)("p",null,"If the artifact referenced by a provider (such as a URL or a GitHub Release) is\nno longer available (or its contents change), executing the DotSlash file will\nfail if the artifact has not already been added to your DotSlash cache. Though\nif the artifact ",(0,i.mdx)("em",{parentName:"p"},"is")," already in your DotSlash cache, DotSlash will not consult\nthe provider again, so the DotSlash file will continue to work until the cache\nis cleared."),(0,i.mdx)("p",null,"This means that when you specify a provider in a DotSlash file, you are\nsignaling to your users that you expect the artifact to be fetchable for as long\nas the DotSlash file is meant to be used. Admittedly, it is impossible to\nguarantee that a provider will work 100% of the time, which is one of the\nreasons why DotSlash supports specifying\n",(0,i.mdx)("a",{parentName:"p",href:"../dotslash-file/#providers"},"multiple providers")," for an artifact, adding some\namount of redundancy."),(0,i.mdx)("p",null,"Take care to consider the reliability of your providers when creating a DotSlash\nfile."),(0,i.mdx)("h2",{id:"debug-symbols"},"Debug Symbols"),(0,i.mdx)("p",null,"We encourage executables to be deployed with ",(0,i.mdx)("inlineCode",{parentName:"p"},"strip")," to reduce size, but that is\nundesirable for a certain class of users."),(0,i.mdx)("h2",{id:"potential-version-skew-between-code-changes-and-dotslash-changes"},"Potential Version Skew Between Code Changes and DotSlash Changes"),(0,i.mdx)("p",null,"If you do monorepo-based development, you may have things set up such that you\nprefer to build everything from source, every time. For example, at Meta, we are\nheavy users of ",(0,i.mdx)("a",{parentName:"p",href:"https://github.com/facebook/fbthrift"},"Thrift"),", and the code for\nthe Thrift compiler lives in our repo. This means that projects that are\neveryday users of Thrift have to spend some of their build cycles building the\nThrift compiler from source before they can build their own binary. (At Meta, we\nleverage distributed builds and caching to mitigate the cost of having to build\ncommon infrastructure such as Thrift.)"),(0,i.mdx)("p",null,"While this may be undesirable to the average Thrift service developer at Meta,\nit is invaluable to the Thrift team and their ability to move the toolchain\nforward. That is, it makes it straightforward to make a local change to the\nThrift compiler and see what effect it has by rebuilding any project of interest\nin the monorepo that depends on Thrift. In the event that a service needs to be\nupdated as a result of a Thrift compiler change, both changes can be done as\npart of the same commit such that the overall change can be landed atomically."),(0,i.mdx)("p",null,"That said, waiting to build the Thrift compiler can be a drag, so it is tempting\nto vendor the Thrift compiler (ideally one built with full Clang optimizations!)\nin the monorepo as a DotSlash file, but this introduces a potential version skew\nissue. That is, the repo also contains Thrift library code that is developed in\ntandem with the Thrift compiler. So long as both the compiler and library are\nbuilt from source, no consistency issues arise."),(0,i.mdx)("p",null,"By comparison, consider a scenario where the DotSlash file wrapping the Thrift\ncompiler were rebuilt once a week. In that world, a Thrift developer (who is\npresumably building the entire Thrift toolchain from source) could easily find\nthemselves in a position where they need to update both the library and the\ncompiler together. This is problematic because landing such a commit could put\nthe library and the vendored Thrift compiler in an incompatible state until the\nDotSlash file were rebuilt with the latest compiler changes."),(0,i.mdx)("p",null,"While there are strategies that can be employed to circumvent this issue (such\nas having two copies of the code, e.g., ",(0,i.mdx)("inlineCode",{parentName:"p"},"dev/")," and ",(0,i.mdx)("inlineCode",{parentName:"p"},"release/"),' folders where a\n"release" entails regenerating the DotSlash file based on the contents of ',(0,i.mdx)("inlineCode",{parentName:"p"},"dev/"),"\nand then copying everything over to ",(0,i.mdx)("inlineCode",{parentName:"p"},"release/"),"), scenarios similar to this\nThrift example are arguably not a good fit for DotSlash."))}u.isMDXComponent=!0}}]);