"use strict";(self.webpackChunkdotslash_website=self.webpackChunkdotslash_website||[]).push([[507],{3905:(e,t,a)=>{a.r(t),a.d(t,{MDXContext:()=>m,MDXProvider:()=>h,mdx:()=>x,useMDXComponents:()=>p,withMDXComponents:()=>s});var n=a(67294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(){return r=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var a=arguments[t];for(var n in a)Object.prototype.hasOwnProperty.call(a,n)&&(e[n]=a[n])}return e},r.apply(this,arguments)}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function d(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var m=n.createContext({}),s=function(e){return function(t){var a=p(t.components);return n.createElement(e,r({},t,{components:a}))}},p=function(e){var t=n.useContext(m),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},h=function(e){var t=p(e.components);return n.createElement(m.Provider,{value:t},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},f=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,m=d(e,["components","mdxType","originalType","parentName"]),s=p(a),h=i,c=s["".concat(l,".").concat(h)]||s[h]||u[h]||r;return a?n.createElement(c,o(o({ref:t},m),{},{components:a})):n.createElement(c,o({ref:t},m))}));function x(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,l=new Array(r);l[0]=f;var o={};for(var d in t)hasOwnProperty.call(t,d)&&(o[d]=t[d]);o.originalType=e,o[c]="string"==typeof e?e:i,l[1]=o;for(var m=2;m<r;m++)l[m]=a[m];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}f.displayName="MDXCreateElement"},94121:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>m});var n=a(87462),i=(a(67294),a(3905));const r={sidebar_position:12},l="DotSlash File Schema",o={unversionedId:"dotslash-file",id:"dotslash-file",title:"DotSlash File Schema",description:"This article explains the requirements for a DotSlash file, so we will use a",source:"@site/docs/dotslash-file.md",sourceDirName:".",slug:"/dotslash-file",permalink:"/docs/dotslash-file",draft:!1,editUrl:"https://github.com/facebook/dotslash/tree/main/website/docs/dotslash-file.md",tags:[],version:"current",sidebarPosition:12,frontMatter:{sidebar_position:12},sidebar:"tutorialSidebar",previous:{title:"Installing DotSlash",permalink:"/docs/installation"},next:{title:"Command Line Flags",permalink:"/docs/flags"}},d={},m=[{value:"Verification",id:"verification",level:2},{value:"Providers",id:"providers",level:2},{value:"HTTP Provider",id:"http-provider",level:3},{value:"GitHub Release Provider",id:"github-release-provider",level:3},{value:"Artifact Format",id:"artifact-format",level:2},{value:"Path",id:"path",level:3},{value:"Format",id:"format",level:3},{value:"Readonly",id:"readonly",level:2}],s={toc:m},p="wrapper";function h(e){let{components:t,...a}=e;return(0,i.mdx)(p,(0,n.Z)({},s,a,{components:t,mdxType:"MDXLayout"}),(0,i.mdx)("h1",{id:"dotslash-file-schema"},"DotSlash File Schema"),(0,i.mdx)("p",null,"This article explains the requirements for a DotSlash file, so we will use a\nworking example for reference. The following is a DotSlash file for the ",(0,i.mdx)("inlineCode",{parentName:"p"},"hermes"),"\nCLI taken from the\n",(0,i.mdx)("a",{parentName:"p",href:"https://github.com/facebook/hermes/releases/tag/v0.12.0"},"v0.12.0 release on GitHub"),".\nIncidentally, the entries for ",(0,i.mdx)("inlineCode",{parentName:"p"},'"macos-x86_64"')," and ",(0,i.mdx)("inlineCode",{parentName:"p"},'"macos-aarch64"')," are\nidentical because on macOS, Hermes is provided as a\n",(0,i.mdx)("a",{parentName:"p",href:"https://developer.apple.com/documentation/apple-silicon/building-a-universal-macos-binary"},"Universal Binary"),",\nso the same artifact works for both architectures:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-json"},'#!/usr/bin/env dotslash\n\n// This DotSlash file represents the hermes CLI across multiple platforms for\n// the v0.12.0 release of Hermes: https://github.com/facebook/hermes/releases/tag/v0.12.0\n\n{\n  "name": "hermes",\n  "platforms": {\n    "macos-x86_64": {\n      "size": 10600817,\n      "hash": "blake3",\n      "digest": "25f984911f199f9229ca0327c52700fa9a8db9aefe95e84f91ba6be69902436a",\n      "format": "tar.gz",\n      "path": "hermes",\n      "providers": [\n        {\n          "url": "https://github.com/facebook/hermes/releases/download/v0.12.0/hermes-cli-darwin-v0.12.0.tar.gz"\n        },\n        {\n          "type": "github-release",\n          "repo": "facebook/hermes",\n          "tag": "v0.12.0",\n          "name": "hermes-cli-darwin-v0.12.0.tar.gz"\n        }\n      ],\n    },\n    "macos-aarch64": {\n      "size": 10600817,\n      "hash": "blake3",\n      "digest": "25f984911f199f9229ca0327c52700fa9a8db9aefe95e84f91ba6be69902436a",\n      "format": "tar.gz",\n      "path": "hermes",\n      "providers": [\n        {\n          "url": "https://github.com/facebook/hermes/releases/download/v0.12.0/hermes-cli-darwin-v0.12.0.tar.gz"\n        },\n        {\n          "type": "github-release",\n          "repo": "facebook/hermes",\n          "tag": "v0.12.0",\n          "name": "hermes-cli-darwin-v0.12.0.tar.gz"\n        }\n      ],\n    },\n    "linux-x86_64": {\n      "size": 47099598,\n      "hash": "blake3",\n      "digest": "8d2c1bcefc2ce6e278167495810c2437e8050780ebb4da567811f1d754ad198c",\n      "format": "tar.gz",\n      "path": "hermes",\n      "providers": [\n        {\n          "url": "https://github.com/facebook/hermes/releases/download/v0.12.0/hermes-cli-linux-v0.12.0.tar.gz"\n        },\n        {\n          "type": "github-release",\n          "repo": "facebook/hermes",\n          "tag": "v0.12.0",\n          "name": "hermes-cli-linux-v0.12.0.tar.gz"\n        }\n      ],\n    },\n    "windows-x86_64": {\n      "size": 17456100,\n      "hash": "blake3",\n      "digest": "7efee4f92a05e34ccfa7c21c7a05f939d8b724bc802423d618db22efb83bfe1b",\n      "format": "tar.gz",\n      "path": "hermes.exe",\n      "providers": [\n        {\n          "url": "https://github.com/facebook/hermes/releases/download/v0.12.0/hermes-cli-windows-v0.12.0.tgz"\n        },\n        {\n          "type": "github-release",\n          "repo": "facebook/hermes",\n          "tag": "v0.12.0",\n          "name": "hermes-cli-windows-v0.12.0.tgz"\n        }\n      ],\n    }\n  }\n}\n')),(0,i.mdx)("p",null,"The general structure of a DotSlash file is:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-json"},'#!/usr/bin/env dotslash\n\n{\n  "name": /* string */,\n  "platforms": /* map */,\n}\n')),(0,i.mdx)("p",null,"That is, the file ",(0,i.mdx)("strong",{parentName:"p"},"must")," start with ",(0,i.mdx)("inlineCode",{parentName:"p"},"#!/usr/bin/env dotslash")," followed\nimmediately by either ",(0,i.mdx)("inlineCode",{parentName:"p"},"\\n")," or ",(0,i.mdx)("inlineCode",{parentName:"p"},"\\r\\n"),'. The required "shebang header" must be\nfollowed by a JSON payload, which is required to be a map with the following\nproperties:'),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},'"name"')," must be a string that represents the name of the executable (it often\nmatches the name of the DotSlash file)"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},'"platforms"')," must be a map of supported platforms to artifacts")),(0,i.mdx)("admonition",{type:"tip"},(0,i.mdx)("p",{parentName:"admonition"},"The JSON payload in a DotSlash file is parsed with a\n",(0,i.mdx)("a",{parentName:"p",href:"https://crates.io/crates/serde_jsonrc"},"lenient JSON parser")," that allows for\ntrailing commas as well as ",(0,i.mdx)("inlineCode",{parentName:"p"},"//")," and ",(0,i.mdx)("inlineCode",{parentName:"p"},"/*"),"-style comments.")),(0,i.mdx)("p",null,"The keys in the ",(0,i.mdx)("inlineCode",{parentName:"p"},'"platforms"')," map take on a format inspired by\n",(0,i.mdx)("a",{parentName:"p",href:"https://clang.llvm.org/docs/CrossCompilation.html"},"Clang triples"),". Today,\nDotSlash supports the following keys in the ",(0,i.mdx)("inlineCode",{parentName:"p"},'"platforms"')," map:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"linux-aarch64")),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"linux-x86_64")),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"macos-aarch64")),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"macos-x86_64")),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"windows-aarch64")),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"windows-x86_64"))),(0,i.mdx)("p",null,"When ",(0,i.mdx)("inlineCode",{parentName:"p"},"dotslash")," runs a DotSlash file, it considers only the entry in\n",(0,i.mdx)("inlineCode",{parentName:"p"},'"platforms"')," that corresponds to the target platform for which that version of\n",(0,i.mdx)("inlineCode",{parentName:"p"},"dotslash")," was built. The schema of such a ",(0,i.mdx)("em",{parentName:"p"},"platform entry")," that specifies the\nartifact to fetch is as follows:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-json"},'{\n  "size": /* size of the artifact in bytes (nonnegative integer) */,\n  "hash": /* name of hash algorithm: either "sha256" or "blake3" */,\n  "digest": /* artifact digest as a lowercase hex string */,\n  "providers": /* array of providers */,\n  "format": /* recognized format, such as "tar.gz"; see list below */,\n  "path": /* filename or path within an archive */,\n  "readonly": /* `false` disables `chmod -R -w` on the unpacked artifact */,\n}\n')),(0,i.mdx)("p",null,"A platform entry must specify several fields:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"The ",(0,i.mdx)("inlineCode",{parentName:"li"},"size"),", ",(0,i.mdx)("inlineCode",{parentName:"li"},"hash"),", and ",(0,i.mdx)("inlineCode",{parentName:"li"},"digest")," are used to verify that the fetched artifact\nhas the expected contents. When DotSlash fetches a blob using a provider, it\nwill not decompress or run it if the ",(0,i.mdx)("inlineCode",{parentName:"li"},"size"),"/",(0,i.mdx)("inlineCode",{parentName:"li"},"hash"),"/",(0,i.mdx)("inlineCode",{parentName:"li"},"digest")," does not match\nwhat is in the DotSlash file."),(0,i.mdx)("li",{parentName:"ul"},"The list of ",(0,i.mdx)("inlineCode",{parentName:"li"},"providers")," specifies how/where DotSlash can try to acquire the\nartifact. A provider will get the opportunity to write the artifact to a\ntemporary file on disk where DotSlash will verify it before proceeding."),(0,i.mdx)("li",{parentName:"ul"},"In the event of a successful fetch, the ",(0,i.mdx)("inlineCode",{parentName:"li"},"format")," and ",(0,i.mdx)("inlineCode",{parentName:"li"},"path")," entries determine\nhow the artifact should be decompressed and, in the case of an archive, the\nentry within the archive to execute when the DotSlash file is run.")),(0,i.mdx)("p",null,"Let's discuss to role of each of set of parameters in more detail."),(0,i.mdx)("h2",{id:"verification"},"Verification"),(0,i.mdx)("p",null,"To ensure that the artifact that was fetched matches what the author of the\nDotSlash file intended, once the artifact is on disk, its content is verified\nagainst the ",(0,i.mdx)("inlineCode",{parentName:"p"},"size"),", ",(0,i.mdx)("inlineCode",{parentName:"p"},"hash"),", and ",(0,i.mdx)("inlineCode",{parentName:"p"},"digest")," parameters."),(0,i.mdx)("p",null,"Today, the only acceptable values for ",(0,i.mdx)("inlineCode",{parentName:"p"},"hash")," are ",(0,i.mdx)("inlineCode",{parentName:"p"},'"sha256"')," and ",(0,i.mdx)("inlineCode",{parentName:"p"},'"blake3"'),",\nwhich correspond to the SHA-256 and BLAKE3 hash functions, respectively."),(0,i.mdx)("p",null,'From the command line, you can use DotSlash\'s "hidden" subcommands to compute\nthe hash for a file on disk, which is handy if you do not have ',(0,i.mdx)("inlineCode",{parentName:"p"},"shasum -a 256"),"\nor ",(0,i.mdx)("inlineCode",{parentName:"p"},"b3sum")," readily available on your ",(0,i.mdx)("inlineCode",{parentName:"p"},"$PATH"),":"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-shell"},"$ echo 'DotSlash Rulez!' > /tmp/dotslash-example.txt\n$ dotslash -- sha256 /tmp/dotslash-example.txt\n52aa28f4f276bdd9a103fcd7f74f97f2bffc52dd816b887952f791b39356b08e\n$ dotslash -- b3sum /tmp/dotslash-example.txt\n824ecff042b9ac68a33ea5ee027379a09f3da1d5a47f29fc52072809a204db87\n")),(0,i.mdx)("h2",{id:"providers"},"Providers"),(0,i.mdx)("p",null,"The ",(0,i.mdx)("inlineCode",{parentName:"p"},"providers")," parameter must be a list even though in practice, it often\ncontains only one value."),(0,i.mdx)("p",null,"A provider is specified via a JSON object that has a ",(0,i.mdx)("inlineCode",{parentName:"p"},'"type"')," field to tell\nDotSlash what type of provider it is, though if unspecified, ",(0,i.mdx)("inlineCode",{parentName:"p"},'"http"')," is\nassumed. Each provider defines its own schema with respect to the other fields\nthat must be specified on the JSON object."),(0,i.mdx)("p",null,"Currently, DotSlash supports two providers out of the box: the ",(0,i.mdx)("strong",{parentName:"p"},"HTTP Provider"),"\n(",(0,i.mdx)("inlineCode",{parentName:"p"},'"type": "http"'),") and the ",(0,i.mdx)("strong",{parentName:"p"},"GitHub Release Provider"),"\n(",(0,i.mdx)("inlineCode",{parentName:"p"},'"type": "github-release"'),"). (At the time of this writing, there is no way to\nadd custom providers without forking DotSlash.)"),(0,i.mdx)("p",null,"Each provider in the ",(0,i.mdx)("inlineCode",{parentName:"p"},"providers")," list will be tried, in order, to fetch the\nartifact, until one succeeds. The provider type need not be unique within a\nlist, e.g., the HTTP Provider can be specified multiple times with different\nvalues for ",(0,i.mdx)("inlineCode",{parentName:"p"},'"url"'),". Though note that the ",(0,i.mdx)("inlineCode",{parentName:"p"},"size"),"/",(0,i.mdx)("inlineCode",{parentName:"p"},"hash"),"/",(0,i.mdx)("inlineCode",{parentName:"p"},"digest")," are specified\n",(0,i.mdx)("em",{parentName:"p"},"independently")," of the providers, so all providers must yield the same artifact."),(0,i.mdx)("h3",{id:"http-provider"},"HTTP Provider"),(0,i.mdx)("p",null,"As shown in the Hermes example, the only required field when using the HTTP\nprovider is the ",(0,i.mdx)("inlineCode",{parentName:"p"},'"url"')," that specifies the URL from which to fetch the artifact\nvia ",(0,i.mdx)("inlineCode",{parentName:"p"},"HTTP GET")," using ",(0,i.mdx)("inlineCode",{parentName:"p"},"curl"),"."),(0,i.mdx)("admonition",{type:"tip"},(0,i.mdx)("p",{parentName:"admonition"},(0,i.mdx)("inlineCode",{parentName:"p"},"curl")," requests from DotSlash include a custom user-agent that looks something\nlike this:"),(0,i.mdx)("pre",{parentName:"admonition"},(0,i.mdx)("code",{parentName:"pre",className:"language-shell"},"Mozilla/5.0 (compatible; DotSlash/0.1.0; +https://dotslash-cli.com)\n"))),(0,i.mdx)("p",null,"Note that in order to facilitate creating a DotSlash file by hand, you can use\nDotSlash's ",(0,i.mdx)("inlineCode",{parentName:"p"},"create-url-entry")," subcommand to generate the boilerplate for a\nplatform entry based on a URL as follows:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-shell"},'$ dotslash -- create-url-entry https://github.com/facebook/hermes/releases/download/v0.12.0/hermes-cli-linux-v0.12.0.tar.gz\n{\n  "size": 47099598,\n  "hash": "blake3",\n  "digest": "8d2c1bcefc2ce6e278167495810c2437e8050780ebb4da567811f1d754ad198c",\n  "format": "tar.gz",\n  "path": "TODO: specify the appropriate `path` for this artifact",\n  "providers": [\n    {\n      "url": "https://github.com/facebook/hermes/releases/download/v0.12.0/hermes-cli-linux-v0.12.0.tar.gz"\n    }\n  ]\n}\n')),(0,i.mdx)("p",null,"That is, ",(0,i.mdx)("inlineCode",{parentName:"p"},"create-url-entry"),' will download the file at the specified URL, compute\nits size in bytes as well as its BLAKE3 hash, and then print "approximately" the\nJSON needed to represent this artifact in a DotSlash file. The following caveats\napply to the output:'),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"The default value of ",(0,i.mdx)("inlineCode",{parentName:"li"},'"path"')," is a ",(0,i.mdx)("inlineCode",{parentName:"li"},"TODO")," because ",(0,i.mdx)("inlineCode",{parentName:"li"},"create-url-entry")," does not\nknow which path within the ",(0,i.mdx)("inlineCode",{parentName:"li"},".tar.gz")," archive is intended to be used in the\nDotSlash file you are trying to generate."),(0,i.mdx)("li",{parentName:"ul"},"In this case, ",(0,i.mdx)("inlineCode",{parentName:"li"},'"format"')," happens to be the appropriate value (",(0,i.mdx)("inlineCode",{parentName:"li"},'"tar.gz"'),")\nbecause DotSlash guessed correctly based on the suffix of the URL; however,\nthis logic is based on a set of heuristics, so it could choose the wrong\nvalue. Be sure to check the value of ",(0,i.mdx)("inlineCode",{parentName:"li"},'"format"')," when using the output of this\ntool.")),(0,i.mdx)("p",null,"Bear in mind that if the ",(0,i.mdx)("inlineCode",{parentName:"p"},'"url"')," is not publicly accessible (or is not\naccessible to the user if, say, it can only be accessed while on a VPN), the\n",(0,i.mdx)("inlineCode",{parentName:"p"},"curl")," request will fail. In such cases, a different type of provider may be the\nsolution."),(0,i.mdx)("h3",{id:"github-release-provider"},"GitHub Release Provider"),(0,i.mdx)("p",null,"The GitHub Release Provider facilitates fetching artifacts that are published as\npart of a release in a GitHub repository. Unlike the HTTP Provider, it uses\n",(0,i.mdx)("a",{parentName:"p",href:"https://cli.github.com"},"the GitHub CLI (",(0,i.mdx)("inlineCode",{parentName:"a"},"gh"),")")," to fetch an artifact. Users are\nresponsible for installing ",(0,i.mdx)("inlineCode",{parentName:"p"},"gh")," and making it available on their ",(0,i.mdx)("inlineCode",{parentName:"p"},"$PATH"),"."),(0,i.mdx)("p",null,"The primary advantage of using this provider over the HTTP provider is that it\ncan fetch artifacts from non-public GitHub URLs, such as private repositories or\nrepositories hosted on a GitHub Enterprise instance, so long as the user has\nauthenticated via ",(0,i.mdx)("inlineCode",{parentName:"p"},"gh auth")," so the CLI can read from those repositories."),(0,i.mdx)("p",null,"An instance of the provider such as:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-json"},'{\n  "type": "github-release",\n  "repo": "facebook/hermes",\n  "tag": "v0.12.0",\n  "name": "hermes-cli-linux-v0.12.0.tar.gz"\n}\n')),(0,i.mdx)("p",null,"gets translated into the following command in order to do the fetch:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-shell"},"gh release download v0.12.0 \\\n  --repo facebook/hermes \\\n  --pattern 'hermes-cli-linux-v0\\.12\\.0\\.tar\\.gz' \\\n  --output TEMPFILE_IN_DOTSLASH_CACHE\n")),(0,i.mdx)("p",null,"Note that if the ",(0,i.mdx)("inlineCode",{parentName:"p"},"facebook/hermes")," repo were part of a GitHub Enterprise\ninstance hosted on ",(0,i.mdx)("inlineCode",{parentName:"p"},"example.com"),", the JSON in the DotSlash file would have to\nbe:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-json"},'{\n  "type": "github-release",\n  // Note the change to this value!\n  "repo": "example.com/facebook/hermes",\n  "tag": "v0.12.0",\n  "name": "hermes-cli-linux-v0.12.0.tar.gz"\n}\n')),(0,i.mdx)("p",null,"And the ",(0,i.mdx)("inlineCode",{parentName:"p"},"--repo")," value passed to ",(0,i.mdx)("inlineCode",{parentName:"p"},"gh")," would also be changed, accordingly."),(0,i.mdx)("h2",{id:"artifact-format"},"Artifact Format"),(0,i.mdx)("p",null,"Although it may appear that ",(0,i.mdx)("inlineCode",{parentName:"p"},"format")," can be an arbitrary file extension,\nDotSlash recognizes a ",(0,i.mdx)("strong",{parentName:"p"},"fixed set of values")," that have the following\nproperties:"),(0,i.mdx)("table",null,(0,i.mdx)("thead",{parentName:"table"},(0,i.mdx)("tr",{parentName:"thead"},(0,i.mdx)("th",{parentName:"tr",align:null},(0,i.mdx)("inlineCode",{parentName:"th"},"format")),(0,i.mdx)("th",{parentName:"tr",align:null},"Archive?"),(0,i.mdx)("th",{parentName:"tr",align:null},"Decompress?"))),(0,i.mdx)("tbody",{parentName:"table"},(0,i.mdx)("tr",{parentName:"tbody"},(0,i.mdx)("td",{parentName:"tr",align:null},(0,i.mdx)("inlineCode",{parentName:"td"},"tar.gz")),(0,i.mdx)("td",{parentName:"tr",align:null},"yes"),(0,i.mdx)("td",{parentName:"tr",align:null},"gzip")),(0,i.mdx)("tr",{parentName:"tbody"},(0,i.mdx)("td",{parentName:"tr",align:null},(0,i.mdx)("inlineCode",{parentName:"td"},"tar.xz")),(0,i.mdx)("td",{parentName:"tr",align:null},"yes"),(0,i.mdx)("td",{parentName:"tr",align:null},"xz")),(0,i.mdx)("tr",{parentName:"tbody"},(0,i.mdx)("td",{parentName:"tr",align:null},(0,i.mdx)("inlineCode",{parentName:"td"},"tar.zst")),(0,i.mdx)("td",{parentName:"tr",align:null},"yes"),(0,i.mdx)("td",{parentName:"tr",align:null},"zstd")),(0,i.mdx)("tr",{parentName:"tbody"},(0,i.mdx)("td",{parentName:"tr",align:null},(0,i.mdx)("inlineCode",{parentName:"td"},"tar")),(0,i.mdx)("td",{parentName:"tr",align:null},"yes"),(0,i.mdx)("td",{parentName:"tr",align:null},(0,i.mdx)("em",{parentName:"td"},"none"))),(0,i.mdx)("tr",{parentName:"tbody"},(0,i.mdx)("td",{parentName:"tr",align:null},(0,i.mdx)("inlineCode",{parentName:"td"},"zip")),(0,i.mdx)("td",{parentName:"tr",align:null},"yes"),(0,i.mdx)("td",{parentName:"tr",align:null},"zip")),(0,i.mdx)("tr",{parentName:"tbody"},(0,i.mdx)("td",{parentName:"tr",align:null},(0,i.mdx)("inlineCode",{parentName:"td"},"gz")),(0,i.mdx)("td",{parentName:"tr",align:null},"no"),(0,i.mdx)("td",{parentName:"tr",align:null},"gzip")),(0,i.mdx)("tr",{parentName:"tbody"},(0,i.mdx)("td",{parentName:"tr",align:null},(0,i.mdx)("inlineCode",{parentName:"td"},"xz")),(0,i.mdx)("td",{parentName:"tr",align:null},"no"),(0,i.mdx)("td",{parentName:"tr",align:null},"xz")),(0,i.mdx)("tr",{parentName:"tbody"},(0,i.mdx)("td",{parentName:"tr",align:null},(0,i.mdx)("inlineCode",{parentName:"td"},"zst")),(0,i.mdx)("td",{parentName:"tr",align:null},"no"),(0,i.mdx)("td",{parentName:"tr",align:null},"zstd")),(0,i.mdx)("tr",{parentName:"tbody"},(0,i.mdx)("td",{parentName:"tr",align:null},(0,i.mdx)("em",{parentName:"td"},"omitted")),(0,i.mdx)("td",{parentName:"tr",align:null},"no"),(0,i.mdx)("td",{parentName:"tr",align:null},(0,i.mdx)("em",{parentName:"td"},"none"))))),(0,i.mdx)("p",null,"An artifact is either an ",(0,i.mdx)("em",{parentName:"p"},"archive")," (such as a ",(0,i.mdx)("inlineCode",{parentName:"p"},".tar")," file) or a ",(0,i.mdx)("em",{parentName:"p"},"single file"),"."),(0,i.mdx)("h3",{id:"path"},"Path"),(0,i.mdx)("p",null,"Because the ",(0,i.mdx)("inlineCode",{parentName:"p"},"path")," identifies the file to execute within the unpacked artifact's\ndirectory in the DotSlash cache, the ",(0,i.mdx)("inlineCode",{parentName:"p"},"format")," determines how the ",(0,i.mdx)("inlineCode",{parentName:"p"},"path")," will be\ninterpreted:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"In the case of an ",(0,i.mdx)("em",{parentName:"li"},"archive"),", it will be unpacked in its own directory in the\nDotSlash cache. The ",(0,i.mdx)("inlineCode",{parentName:"li"},"path")," specifies the relative path within that directory\nas the file to run when the DotSlash file is executed."),(0,i.mdx)("li",{parentName:"ul"},"In the case of a ",(0,i.mdx)("em",{parentName:"li"},"single file"),", a new, empty directory will also be written in\nthe DotSlash cache. The ",(0,i.mdx)("inlineCode",{parentName:"li"},"path")," specifies the relative path where the file\nshould be written in that directory.")),(0,i.mdx)("p",null,"DotSlash has strict requirements for the ",(0,i.mdx)("inlineCode",{parentName:"p"},"path")," parameter:"),(0,i.mdx)("admonition",{type:"important"},(0,i.mdx)("p",{parentName:"admonition"},(0,i.mdx)("inlineCode",{parentName:"p"},"path")," ",(0,i.mdx)("strong",{parentName:"p"},"must")," be specified as a ",(0,i.mdx)("em",{parentName:"p"},"normalized, relative UNIX path"),", even for\nWindows artifacts.")),(0,i.mdx)("p",null,'This restriction is designed to prevent referencing files "outside" the cache\nvia either relative or absolute paths. To reduce ambiguity, DotSlash rejects a\n',(0,i.mdx)("inlineCode",{parentName:"p"},"path")," that contains a backslash (",(0,i.mdx)("inlineCode",{parentName:"p"},"\\"),') even though it is an allowed character\nfor a "normal" path component on UNIX.'),(0,i.mdx)("p",null,"These are ",(0,i.mdx)("strong",{parentName:"p"},"valid values")," for ",(0,i.mdx)("inlineCode",{parentName:"p"},"path"),":"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"buck2")),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"buck2.exe")),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"path/to/buck2")),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"path/to/buck2.exe"))),(0,i.mdx)("p",null,"These are ",(0,i.mdx)("strong",{parentName:"p"},"invalid values")," for ",(0,i.mdx)("inlineCode",{parentName:"p"},"path"),":"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"path\\to\\buck2.exe")," (contains ",(0,i.mdx)("inlineCode",{parentName:"li"},"\\"),")"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"/usr/local/bin/buck2")," (absolute path: not relative)"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"./buck2")," (contains current directory component: not normalized)"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"../buck2")," (contains parent directory component: not normalized)"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"buck2/")," (slash at end: not normalized)"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"C:\\Tools\\buck2.exe")," (contains ",(0,i.mdx)("inlineCode",{parentName:"li"},"\\"),")"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"C:/Tools/buck2.exe")," (","[only on Windows]"," contains prefix component: not\nrelative)")),(0,i.mdx)("h3",{id:"format"},"Format"),(0,i.mdx)("p",null,"The ",(0,i.mdx)("inlineCode",{parentName:"p"},"format")," describes how the artifact is packaged, which in turn defines how\nDotSlash will unpack it."),(0,i.mdx)("admonition",{type:"warning"},(0,i.mdx)("p",{parentName:"admonition"},"To reiterate, ",(0,i.mdx)("inlineCode",{parentName:"p"},"format")," cannot be an arbitrary file extension. For example, if\nyou have a gzipped-tarball that is served from a URL ending with ",(0,i.mdx)("inlineCode",{parentName:"p"},".tgz"),", you\nmust still classify it using ",(0,i.mdx)("inlineCode",{parentName:"p"},'"format": "tar.gz"')," in the DotSlash file because\n",(0,i.mdx)("inlineCode",{parentName:"p"},"tgz")," is not a recognized value for ",(0,i.mdx)("inlineCode",{parentName:"p"},"format"),".")),(0,i.mdx)("p",null,"DotSlash also supports artifacts that are compressed with either gzip or\n",(0,i.mdx)("a",{parentName:"p",href:"https://facebook.github.io/zstd/"},"zstd"),". For artifacts that are compressed\narchives, they will be decompressed before they are unzipped. Note that DotSlash\nincludes its own implementations of gzip and zstd implemented in Rust rather\nthan relying on a an implementation of ",(0,i.mdx)("inlineCode",{parentName:"p"},"gunzip")," or ",(0,i.mdx)("inlineCode",{parentName:"p"},"zstd")," on the user's ",(0,i.mdx)("inlineCode",{parentName:"p"},"$PATH"),"."),(0,i.mdx)("p",null,"Looking at the ",(0,i.mdx)("inlineCode",{parentName:"p"},"hermes")," example above:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"Once it is fetched, the artifact will be decompressed as if it were a\n",(0,i.mdx)("inlineCode",{parentName:"li"},".tar.gz")," file."),(0,i.mdx)("li",{parentName:"ul"},"Within the decompressed archive, the ",(0,i.mdx)("inlineCode",{parentName:"li"},"hermes")," entry should be executed, except\non Windows, in which case the ",(0,i.mdx)("inlineCode",{parentName:"li"},"hermes.exe")," entry should be used instead.")),(0,i.mdx)("p",null,"At Meta, we have found compression to be a win, but if for some reason you\nprefer to fetch your executable as an uncompressed single file, you can omit the\n",(0,i.mdx)("inlineCode",{parentName:"p"},'"format"')," field, but ",(0,i.mdx)("inlineCode",{parentName:"p"},'"path"')," is still required."),(0,i.mdx)("h2",{id:"readonly"},"Readonly"),(0,i.mdx)("p",null,"There is an optional ",(0,i.mdx)("inlineCode",{parentName:"p"},"readonly")," boolean field on an artifact entry. It is not\nintended to be used (it defaults to ",(0,i.mdx)("inlineCode",{parentName:"p"},"true"),"), but is provided as an escape hatch,\nif necessary."),(0,i.mdx)("p",null,"After DotSlash decompresses an artifact in a temporary folder, it marks all of\nthe entries in the folder\n",(0,i.mdx)("a",{parentName:"p",href:"https://doc.rust-lang.org/std/fs/struct.Permissions.html#method.set_readonly"},"read-only"),"\nbefore moving it into its final location in the cache. The idea is that\nexecutables should not be modifying the files in the cache, as that sort of\nbehavior increases the likelihood of non-determinism."),(0,i.mdx)("p",null,"Of course, it is possible that DotSlash is used to deliver an executable that\nmay do something like write to a dotfile alongside the executable when it is\nrun. By default, this write will fail when the executable is run via DotSlash\nbecause the folder is read-only. Ideally, the executable would be redesigned to\nwrite to ",(0,i.mdx)("inlineCode",{parentName:"p"},"$XDG_STATE_HOME")," or whatever is appropriate, but the author of the\nDotSlash file may not be in a position to change that."),(0,i.mdx)("p",null,"In this case, setting ",(0,i.mdx)("inlineCode",{parentName:"p"},"readonly: false")," will disable the logic that marks all of\nthe entries in the temporary folder read-only before it is moved to its final\nlocation in the cache."))}h.isMDXComponent=!0}}]);